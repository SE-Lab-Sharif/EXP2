# EXP2
### گام ۱: افزودن یک روش پیام رسانی دیگر

	تغییراتی را که در کد فعلی برنامه می‌دهید، در جدول زیر ثبت کنید و در نهایت تعداد کل تغییرات را اعلان کنید.
    - توجه: مواردی که به عنوان تغییرات باید اعلان شود شامل این موارد هستند:
      1. ساخت کلاس جدید
      2. افزودن تابع جدید به کلاس و یا واسط (برای توابع جدید صرفا اعلام تغییر کنید)
      3. هر خطوط پیاپی‌ای که در تابع main و برای افزودن یک قابلیت جدید اضافه می‌کنید. به عنوان مثال اگر سه خط را به منظور تشخیص نوع پیام اضافه می‌کنید، آن سه خط را در قالب یک تغییر اعلام کنید (البته جزییات آن را در ستون «شرحی کوتاه از تغییر» توضیح دهید).

<table dir='rtl'>
<tbody>
<tr>
<td width="64">
<p><strong>ردیف</strong></p>
</td>
<td width="198">
<p><strong>محل اعمال تغییرات (کلاس/واسط)</strong></p>
</td>
<td width="141">
<p><strong>عنوان تغییر</strong></p>
</td>
<td width="292">
<p><strong>شرحی کوتاه از تغییر</strong></p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۱</strong></p>
</td>
<td width="198">
<p>MessageService</p>
</td>
<td width="141">
<p>افزودن اینترفیس ارسال پیام</p>
</td>
<td width="292">
<p>افزودن یک تابع void با عنوان sendMessage</p>
</td>
</tr>

<tr>
<td width="64">
<p><strong>۲</strong></p>
</td>
<td width="198">
<p>TelegramService</p>
</td>
<td width="141">
<p>ارث بری از MessageService</p>
</td>
<td width="292">
<p> پیاده سازی تابع ارسال پیام برای سرویس تلگرام</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۳</strong></p>
</td>
<td width="198">
<p>OnlineOrderService</p>
</td>
<td width="141">
<p>اضافه کردن امکان پیام رسانی به اردر های آنلاین</p>
</td>
<td width="292">
<p>اضافه کردن فیلد مسیجینگ به این کلاس</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۴</strong></p>
</td>
<td width="198">
<p>OnSiteOrderService</p>
</td>
<td width="141">
<p>اضافه کردن امکان پیام رسانی به اردر های حضوری</p>
</td>
<td width="292">
<p>اضافه کردن فیلد مسیجینگ به این کلاس</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۵</strong></p>
</td>
<td width="198">
<p>Main</p>
</td>
<td width="141">
<p>
اضافه کردن امکان پیام رسانی
</p>
</td>
<td width="292">
<p>
اضافه کردن فیلد تلگرام مسیجینگ به بدنه تابع مین
</p>
</td>
</tr>

</tbody>
</table>

مجموع تعداد تغییرات: ..............

### گام ۲: تحلیل و وارسی برنامه از منظر تحقق و یا عدم تحقق اصول SOLID
<table dir='rtl'>
<tbody>
<tr>
<td rowspan="2" width="240">
<p>اصل 1</p>
<p>Single Responsibility</p>
</td>
<td width="95">
<p><strong>موارد تحقق</strong></p>
</td>
<td width="454">
<p>
کلاس‌های OnlineOrderService و OnSiteOrderService تنها وظیفه پردازش و ثبت سفارشات و همچنین پرداخت‌ها را بر عهده دارند. اما این کلاس‌ها از MessagingService نیز استفاده می‌کنند تا پیام‌ها را ارسال کنند.
</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>
با اضافه شدن ارسال پیام به این کلاس‌ها، اصل تک‌مسئولیتی نقض می‌شود، زیرا اکنون علاوه بر مدیریت سفارش، وظیفه ارسال پیام را نیز بر عهده دارند.
</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 2</p>
<p>Open-Close Principle (OCP)</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>
با استفاده از اینترفیس MessagingService، می‌توانیم پیام‌رسان‌های دیگری مانند سرویس ایمیل را بدون نیاز به تغییر در کد موجود اضافه کنیم.
</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>
برای OrderService به دلیل نیاز به تغییر کد Main در صورت اضافه شدن پیام‌رسان‌های دیگر، هنوز OCP کامل نیست.
</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 3</p>
<p>Liskov Substitution Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>
کلاس TelegramService به درستی این اصل را رعایت می‌کند، زیرا می‌تواند به عنوان پیاده‌سازی MessagingService در همه جا به کار رود.
</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 4</p>
<p>Interface Segregation Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>
MessagingService تنها یک متد sendMessage دارد و از اصل ISP تبعیت می‌کند.</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td rowspan="2">
<p>اصل 5</p>
<p>Dependency Inversion Principle</p>
</td>
<td>
<p><strong>موارد تحقق</strong></p>
</td>
<td>
<p>
در این کد، کلاس‌های OrderService به جای وابستگی به TelegramService مستقیماً از MessagingService استفاده می‌کنند که به درستی DIP را رعایت کرده‌اند.
</p>
</td>
</tr>
<tr>
<td>
<p><strong>موارد نقض</strong></p>
</td>
<td>
<p>وابستگی به MessagingService به صورت دستی در Main ساخته شده و این می‌تواند در پروژه‌های بزرگ مشکل‌ساز شود.</p>
</td>
</tr>
</tbody>
</table>

در خصوص هرکدام از موارد نقض هرکدام از اصول، یک راهکار را به منظور رفع آن مشکل ارایه داده و در جدول زیر ثبت نمایید:

<table dir='rtl'>
<tbody>
<tr>
<td width="168">
<p><strong>اصل مربوطه (از اصول </strong><strong>SOLID</strong><strong>)</strong></p>
</td>
<td width="246">
<p><strong>علت نقض</strong></p>
</td>
<td width="284">
<p><strong>راه حل پیشنهادی</strong></p>
</td>
</tr>
<tr>
<td width="168">
<p>Single Responsibility</p>
</td>
<td width="246">
<p>اکنون علاوه بر مدیریت سفارش، وظیفه ارسال پیام را نیز بر عهده دارند.</p>
</td>
<td width="284">
<p>اضافه کردن کلاس OrderNotifier: این کلاس مسئول ارسال پیام‌ها می‌شود و از MessagingService استفاده می‌کند.</p>
</td>
</tr>
<tr>
<td width="168">
<p>OCP</p>
</td>
<td width="246">
<p>برای OrderService به دلیل نیاز به تغییر کد Main در صورت اضافه شدن پیام‌رسان‌های دیگر، هنوز OCP کامل نیست.</p>
</td>
<td width="284">
<p>ایجاد OrderServiceFactory: این کلاس به ایجاد نمونه‌های OrderService و وابستگی‌های لازم آن‌ها کمک می‌کند و اصل وارونگی وابستگی و باز برای توسعه و بسته برای تغییر را تقویت می‌کند.</p>
</td>
</tr>
<tr>
<td width="168">
<p>DIP</p>
</td>
<td width="246">
<p>وابستگی به MessagingService به صورت دستی در Main ساخته شده و این می‌تواند در پروژه‌های بزرگ مشکل‌ساز شود.</p>
</td>
<td width="284">
<p>استفاده از Dependency Injection که می‌تواند به بهبود مدیریت وابستگی ها منجر بشود.</p>
</td>
</tr>

</tbody>
</table>

### گام ۳: اصلاح موارد نقض
در نهایت، بر اساس تحلیلی که انجام داده‌اید و راه حل‌هایی که در بخش قبل ارایه کردید، کد را اصلاح کرده و بر روی مخزن گیت‌هاب و در پوشه‌ای مجزا از گام قبل commit و push کنید. انتظار می‌رود که تمامی راه حل‌های پیشنهادی خود را بر روی این نسخه اعمال کنید و تمامی بهبودهایی که انجام می‌دهید، در جداول بخش قبل موجود باشد.

### گام ۴: بررسی مجدد تغییرات مورد نیاز
فرض کنید که گام 1 را برای کد اصلاح شده (پس از انجام گام‌های ۲ و ۳) اجرا کرده‌اید.
1. در این صورت از انجام کدام یک از تغییرات ثبت شده در جدول گام ۱ معاف خواهید شد؟
2. تعداد تغییرات مورد نیاز، چند تغییر خواهد شد؟

### گام ۵: جمع بندی
در این بخش، بیان کنید که از این گام چه نتیجه‌ای گرفته‌اید؟ و به نظر شما به کارگیری صحیح اصول SOLID در گام‌های ۳ و ۴ چه مزایایی را نسبت به حالتی دارد که این اصول رعایت نشده‌بود؟
